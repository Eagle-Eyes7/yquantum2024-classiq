{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Classiq's YQuantum 2024 Sparse State-Preparation Challenge\n",
    "\n",
    "Welcome to the Sparse State-Preparation Challenge, presented by Classiq at YQuantum 2024. This challenge is designed for quantum computing enthusiasts of all levels, aiming to enhance your understanding and spur innovation in sparse state-preparation.\n",
    "\n",
    "### Challenge Overview\n",
    "- **Objective**: Develop quantum circuits that efficiently prepare sparse quantum states. These states are characterized by a small number of non-zero amplitudes, reducing quantum resource requirements and enhancing practical execution on near-term quantum hardware.\n",
    "\n",
    "### Background\n",
    "- **Importance of State Preparation**: State preparation is a crucial first step for many quantum algorithms. It involves setting a quantum state to represent a specific vector of probabilities or functions. The challenge focuses on sparse states, which are pivotal in applications like quantum linear algebra and quantum machine learning.\n",
    "\n",
    "### Problem Statement\n",
    "- **Sparse State-Preparation**: Your task is to create circuits that load a quantum state with probabilities corresponding to a given sparse vector. This challenge highlights the nuances of designing circuits that are both efficient and effective for today's quantum computing limitations.\n",
    "\n",
    "### Resources and Guidance\n",
    "- **Classiq's Tools**: Utilize Classiq’s platform, QMOD language, and SDK, which provide robust tools for designing and testing quantum algorithms. Participants are encouraged to base their implementations on \"An Efficient Algorithm for Sparse Quantum State Preparation\" by Niels Gleinig and Torsten Hoefler.\n",
    "\n",
    "### Goals and Expectations\n",
    "- **Output Goal**: Efficiently prepare a quantum state reflecting specified probabilities, ensuring high fidelity and resource efficiency. \n",
    "- **Example**: For input `{‘00000001’: 0.25, ‘00010001’: 0.5, ‘11001000’: 0.25}`, the output quantum state should correspond to these probabilities.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 68,
   "metadata": {},
   "outputs": [],
   "source": [
    "import classiq\n",
    "classiq.authenticate()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 69,
   "metadata": {},
   "outputs": [],
   "source": [
    "from classiq import *\n",
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Classical Functions\n",
    "This section includes utility functions for classical pre-processing in quantum algorithms:\n",
    "\n",
    "- `dict_to_3d_array(sparse_states)`: Converts a dictionary of sparse states into a 3D array format.\n",
    "- `custom_filter(func, iterable)`: Filters items in an iterable based on a function.\n",
    "- `unequal_sets(t, n)`: Determines the best qubit to split a set `t` into subsets with a significant size difference.\n",
    "- `process_subsets(t, n, dif_qubits, dif_values)`: Processes subsets to determine difference qubits and values.\n",
    "- `toggle_operations(index, n, x_x, ops1, ops2, s)`: Toggles operations based on the index condition.\n",
    "- `conditional_toggle(ops1, ops2, n, dif, b, s)`: Conditionally toggles based on a difference.\n",
    "- `calc_alpha_beta(x_1, x_2)`: Calculates and adjusts alpha and beta values."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 70,
   "metadata": {},
   "outputs": [],
   "source": [
    "def dict_to_3d_array(sparse_states):\n",
    "    array_3d = []\n",
    "    \n",
    "    for key, value in sparse_states.items():\n",
    "        point = [int(digit) for digit in key]\n",
    "        array_3d.append([point, value])\n",
    "    \n",
    "    return array_3d\n",
    "\n",
    "def custom_filter(func, iterable):\n",
    "    return [item for item in iterable if func(item)]\n",
    "\n",
    "def unequal_sets(t, n): \n",
    "\n",
    "    best_qubit = None\n",
    "    T_0=[]\n",
    "    T_1=[]\n",
    "    current_difference = float('-inf')\n",
    "\n",
    "    for b in range(n):    \n",
    "        #Filter list based on boolean condition\n",
    "        T_0 = custom_filter(lambda x, b=b: x[0][b] == 0, t)\n",
    "        T_1 = custom_filter(lambda x, b=b: x[0][b] == 1, t)\n",
    "\n",
    "        # Check if both sets are non-empty\n",
    "        if len(T_0) != 0 and len(T_1) != 0:\n",
    "            difference = abs(len(T_0) - len(T_1))\n",
    "            #If new max difference\n",
    "            if difference > current_difference:\n",
    "                current_difference = difference\n",
    "                best_qubit = b\n",
    "                t_0 = T_0\n",
    "                t_1 = T_1\n",
    "    \n",
    "    return best_qubit,t_0, t_1\n",
    "\n",
    "def process_subsets(t, n, dif_qubits, dif_values):\n",
    "    while len(t) > 1:\n",
    "        b, T_0, T_1 = unequal_sets(t, n)\n",
    "        dif_qubits.append(b)\n",
    "        if len(T_0) < len(T_1):\n",
    "            t = T_0\n",
    "            dif_values.append(0)\n",
    "        else:\n",
    "            t = T_1\n",
    "            dif_values.append(1)\n",
    "    return dif_qubits, dif_values, t\n",
    "\n",
    "def toggle_operations(index,n, x_x, ops1, ops2,s):\n",
    "    if x_x[0][index] != 1: #Identical code\n",
    "            ops1 += [1]\n",
    "            ops2 += [n-1-index]\n",
    "            for x in s:\n",
    "                x[0][index]= int(not x[0][index])\n",
    "\n",
    "def conditional_toggle(ops1,ops2,n,dif,b,s):\n",
    "    ops1 += [2]\n",
    "    sx = [n-1-dif,n-1-b]\n",
    "    ops2 += [sx]\n",
    "    for x in s:\n",
    "        if x[0][dif] == 1:\n",
    "            x[0][b] = int(not x[0][b])\n",
    "\n",
    "def calc_alpha_beta(x_1,x_2):\n",
    "    beta = x_1[1]\n",
    "    alpha = x_2[1]\n",
    "\n",
    "    x_2[1] = alpha+beta\n",
    "    alpha = alpha/x_2[1]\n",
    "    beta = beta/x_2[1]\n",
    "\n",
    "    return alpha, beta\n",
    "\n",
    "def calc_angle(alpha, beta):\n",
    "    return np.arctan((beta)**.5/(alpha**.5))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Quantum Functions\n",
    "This section details quantum operations essential for the algorithm:\n",
    "\n",
    "- Quantum functions corresponding to the classical ones, allowing operations on quantum states based on classical pre-processing."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 71,
   "metadata": {},
   "outputs": [],
   "source": [
    "#TODO implement unitary_control() using Classiq's built in control()\n",
    "@qfunc\n",
    "def unitary_control(qubit: QArray[QBit], contrl: QArray[QBit], target: QParam[int]):\n",
    "      # works by indexing to the target qbit in the abit array calling X on this qbit\n",
    "      # and also passing the contrl qbit array as a parameter for the control call\n",
    "      control(lambda: X(qubit[target]), contrl)\n",
    "\n",
    "#TODO implement y_rotation using the RY() gate\n",
    "@qfunc\n",
    "def y_rotation(theta: QParam[float], reg: QArray[QBit], target: QParam[int]):\n",
    "      # literally calling the RY function with theat as the angle and indexing to the target qbit in the reg qbit array\n",
    "      RY(theta, reg[target])\n",
    "\n",
    "@qfunc\n",
    "def my_controlled_unitary(q:QArray[QBit], w:QParam[float], ctrl:QArray[QBit], target:QParam[int]) -> None:\n",
    "      within_apply(compute=lambda: y_rotation(w,q,target), action=lambda: unitary_control(q, ctrl, target))\n",
    "\n",
    "@qfunc\n",
    "def my_unitary(q:QArray[QBit], w:QParam[float], target:QParam[int]) -> None:\n",
    "      within_apply(compute=lambda: y_rotation(w,q,target), action=lambda: X(q[target]))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Sparse State Prep\n",
    "Describes the arguments and setup for preparing a sparse quantum state:\n",
    "\n",
    "- Initial setup includes defining quantum bit requirements and preparing the environment.\n",
    "- Integration of classical functions to set up and manipulate quantum state preparation based on given sparse states.\n",
    "\n",
    "### Algorithm 1\n",
    "- **Purpose**: The primary function of `algorithm_1` is to efficiently prepare a sparse quantum state based on a given set of sparse state descriptions. It utilizes classical pre-processing to determine the optimal sequence of quantum gates.\n",
    "- **Process**:\n",
    "  - It begins by identifying the qubits and the operations that will result in the greatest simplification of the quantum state based on the input data.\n",
    "  - The algorithm iteratively processes subsets of quantum states, toggling qubits and adjusting their probabilities to converge towards the desired sparse state.\n",
    "  - Each iteration updates operation lists which are used to guide the quantum operations on the actual quantum hardware.\n",
    "  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 72,
   "metadata": {},
   "outputs": [],
   "source": [
    "def algorithm_1(s,n, ops1, ops2, ops3, ops4, ops5, n9):\n",
    "    dif_qubits = [] #Where to operate\n",
    "    dif_values = [] #What operation, only ones and zeros\n",
    "\n",
    "    #Preprocessing\n",
    "    T = s\n",
    "\n",
    "    dif_qubits, dif_values, t = process_subsets(T, n, dif_qubits, dif_values)\n",
    "            \n",
    "    dif = dif_qubits.pop()\n",
    "    dif_values.pop()\n",
    "\n",
    "    x_1 = t[0]\n",
    "    t_dagger = [x for x in s if all(x[0][q] == v for q, v in zip(dif_qubits, dif_values))]\n",
    "    t_dagger.remove(x_1)\n",
    "\n",
    "    dif_qubits, dif_values, t_dagger = process_subsets(t_dagger, n, dif_qubits, dif_values)        \n",
    "            \n",
    "    x_2 = t_dagger[0]\n",
    "\n",
    "    #Storing necessary operations\n",
    "    toggle_operations(dif,n,x_1,ops1,ops2,s)\n",
    "            \n",
    "    for b in range(n):\n",
    "        if b != dif and x_1[0][b] != x_2[0][b]:\n",
    "            conditional_toggle(ops1,ops3,n,dif,b,s)\n",
    "\n",
    "    for b in dif_qubits:\n",
    "        toggle_operations(b,n,x_2,ops1,ops2,s)\n",
    "\n",
    "    alpha, beta = calc_alpha_beta(x_1,x_2)\n",
    "    \n",
    "    ops1 += [3]\n",
    "    sy = [alpha,beta, dif_qubits, dif]\n",
    "\n",
    "    if len(dif_qubits) > 0:\n",
    "        n9 += [len(dif_qubits)]\n",
    "    else:\n",
    "        sy.remove(dif_qubits)\n",
    "\n",
    "    ops4 += [sy]\n",
    "    s.remove(x_1)\n",
    "\n",
    "    if len(s) > 1:\n",
    "        algorithm_1(s,n, ops1, ops2, ops3, ops4, ops5, n9)\n",
    "    else:\n",
    "        ops1 += [4]\n",
    "        ops5 += [x_2[0]]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Main Function Implementation\n",
    "- **Purpose**: The `main` function orchestrates the overall setup and execution of the sparse state preparation.\n",
    "- **Functionality**:\n",
    "  - It initializes the quantum environment with the necessary number of qubits based on the input state descriptions.\n",
    "  - The sparse states are first converted into a format suitable for quantum operations using `dict_to_3d_array`.\n",
    "  - The main function then invokes `algorithm_1` to find the necessary operation to prepare the sparse quantum state.\n",
    "  - After `algorithm_1` completes, the `main` function applies the quantum operations to finalize the state preparation.\n",
    "  - It is responsible for managing and applying the computed operations to the quantum system, effectively translating the classical pre-processing results into quantum manipulations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 73,
   "metadata": {},
   "outputs": [
    {
     "ename": "AttributeError",
     "evalue": "'list' object has no attribute 'get_handle_binding'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mAttributeError\u001b[0m                            Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[73], line 96\u001b[0m\n\u001b[0;32m     93\u001b[0m             \u001b[38;5;28;01mif\u001b[39;00m sparse_states[\u001b[38;5;241m0\u001b[39m][\u001b[38;5;241m0\u001b[39m][b]\u001b[38;5;241m==\u001b[39m\u001b[38;5;241m1\u001b[39m:\n\u001b[0;32m     94\u001b[0m                 X(psi[NUM_QUBITS\u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m\u001b[38;5;241m-\u001b[39mb])\n\u001b[1;32m---> 96\u001b[0m model \u001b[38;5;241m=\u001b[39m \u001b[43mcreate_model\u001b[49m\u001b[43m(\u001b[49m\u001b[43mmain\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     97\u001b[0m qprog \u001b[38;5;241m=\u001b[39m synthesize(model)\n\u001b[0;32m     98\u001b[0m show(qprog)\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_function.py:41\u001b[0m, in \u001b[0;36mcreate_model\u001b[1;34m(entry_point, constraints, execution_preferences, preferences, classical_execution_function)\u001b[0m\n\u001b[0;32m     37\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m entry_point\u001b[38;5;241m.\u001b[39mfunc_decl\u001b[38;5;241m.\u001b[39mname \u001b[38;5;241m!=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mmain\u001b[39m\u001b[38;5;124m\"\u001b[39m:\n\u001b[0;32m     38\u001b[0m     \u001b[38;5;28;01mraise\u001b[39;00m ClassiqError(\n\u001b[0;32m     39\u001b[0m         \u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mThe entry point function must be named \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mmain\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m, got \u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mentry_point\u001b[38;5;241m.\u001b[39mfunc_decl\u001b[38;5;241m.\u001b[39mname\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m     40\u001b[0m     )\n\u001b[1;32m---> 41\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mentry_point\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mcreate_model\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m     42\u001b[0m \u001b[43m    \u001b[49m\u001b[43mconstraints\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mexecution_preferences\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mpreferences\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mclassical_execution_function\u001b[49m\n\u001b[0;32m     43\u001b[0m \u001b[43m\u001b[49m\u001b[43m)\u001b[49m\u001b[38;5;241m.\u001b[39mget_model()\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_function.py:74\u001b[0m, in \u001b[0;36mQFunc.create_model\u001b[1;34m(self, constraints, execution_preferences, preferences, classical_execution_function)\u001b[0m\n\u001b[0;32m     72\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_qmodule\u001b[38;5;241m.\u001b[39mconstants \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mdict\u001b[39m()\n\u001b[0;32m     73\u001b[0m QConstant\u001b[38;5;241m.\u001b[39mset_current_model(\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_qmodule)\n\u001b[1;32m---> 74\u001b[0m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_add_native_func_def\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     75\u001b[0m model_extra_settings: List[Tuple[\u001b[38;5;28mstr\u001b[39m, Any]] \u001b[38;5;241m=\u001b[39m [\n\u001b[0;32m     76\u001b[0m     (\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mconstraints\u001b[39m\u001b[38;5;124m\"\u001b[39m, constraints),\n\u001b[0;32m     77\u001b[0m     (\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mexecution_preferences\u001b[39m\u001b[38;5;124m\"\u001b[39m, execution_preferences),\n\u001b[0;32m     78\u001b[0m     (\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mpreferences\u001b[39m\u001b[38;5;124m\"\u001b[39m, preferences),\n\u001b[0;32m     79\u001b[0m ]\n\u001b[0;32m     80\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m classical_execution_function \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m:\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_function.py:95\u001b[0m, in \u001b[0;36mQFunc._add_native_func_def\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m     93\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfunc_decl\u001b[38;5;241m.\u001b[39mname \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_qmodule\u001b[38;5;241m.\u001b[39mnative_defs:\n\u001b[0;32m     94\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m\n\u001b[1;32m---> 95\u001b[0m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mexpand\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     96\u001b[0m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_qmodule\u001b[38;5;241m.\u001b[39mnative_defs[\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfunc_decl\u001b[38;5;241m.\u001b[39mname] \u001b[38;5;241m=\u001b[39m NativeFunctionDefinition(\n\u001b[0;32m     97\u001b[0m     \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mfunc_decl\u001b[38;5;241m.\u001b[39m\u001b[38;5;18m__dict__\u001b[39m, body\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mbody\n\u001b[0;32m     98\u001b[0m )\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_expandable.py:84\u001b[0m, in \u001b[0;36mQExpandable.expand\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m     82\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mexpand\u001b[39m(\u001b[38;5;28mself\u001b[39m) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m     83\u001b[0m     \u001b[38;5;28;01mwith\u001b[39;00m \u001b[38;5;28mself\u001b[39m:\n\u001b[1;32m---> 84\u001b[0m         \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_py_callable\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_get_positional_args\u001b[49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\n",
      "Cell \u001b[1;32mIn[73], line 46\u001b[0m, in \u001b[0;36mmain\u001b[1;34m(psi)\u001b[0m\n\u001b[0;32m     43\u001b[0m omega \u001b[38;5;241m=\u001b[39m calc_angle(my_values[\u001b[38;5;241m0\u001b[39m], my_values[\u001b[38;5;241m1\u001b[39m])\n\u001b[0;32m     44\u001b[0m \u001b[38;5;66;03m# i think this call is formatted correctly but it is not working\u001b[39;00m\n\u001b[0;32m     45\u001b[0m \u001b[38;5;66;03m# might need to have assignments within the function call?\u001b[39;00m\n\u001b[1;32m---> 46\u001b[0m \u001b[43mmy_unitary\u001b[49m\u001b[43m(\u001b[49m\u001b[43mq\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43msparse_states\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mw\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43momega\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mtraget\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[38;5;28;43mint\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m1\u001b[39;49m\u001b[43m)\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     48\u001b[0m \u001b[38;5;66;03m# the previously specified 'some functions'\u001b[39;00m\n\u001b[0;32m     49\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m i \u001b[38;5;129;01min\u001b[39;00m \u001b[38;5;28mrange\u001b[39m(\u001b[38;5;28mlen\u001b[39m(ops1)\u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m, \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m, \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m):\n\u001b[0;32m     50\u001b[0m     \u001b[38;5;66;03m# this for loop is reversed so now we just need to invert the calls also\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_function.py:60\u001b[0m, in \u001b[0;36mQFunc.__call__\u001b[1;34m(self, *args, **kwargs)\u001b[0m\n\u001b[0;32m     59\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m__call__\u001b[39m(\u001b[38;5;28mself\u001b[39m, \u001b[38;5;241m*\u001b[39margs: Any, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs: Any) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[1;32m---> 60\u001b[0m     \u001b[38;5;28;43msuper\u001b[39;49m\u001b[43m(\u001b[49m\u001b[43m)\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[38;5;21;43m__call__\u001b[39;49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     61\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_add_native_func_def()\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_callable.py:46\u001b[0m, in \u001b[0;36mQCallable.__call__\u001b[1;34m(self, *args, **kwargs)\u001b[0m\n\u001b[0;32m     43\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21m__call__\u001b[39m(\u001b[38;5;28mself\u001b[39m, \u001b[38;5;241m*\u001b[39margs: Any, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs: Any) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m \u001b[38;5;28;01mNone\u001b[39;00m:\n\u001b[0;32m     44\u001b[0m     \u001b[38;5;28;01massert\u001b[39;00m QCallable\u001b[38;5;241m.\u001b[39mCURRENT_EXPANDABLE \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;129;01mnot\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m\n\u001b[0;32m     45\u001b[0m     QCallable\u001b[38;5;241m.\u001b[39mCURRENT_EXPANDABLE\u001b[38;5;241m.\u001b[39mappend_statement_to_body(\n\u001b[1;32m---> 46\u001b[0m         \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mcreate_quantum_function_call\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m     47\u001b[0m     )\n\u001b[0;32m     48\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_expandable.py:114\u001b[0m, in \u001b[0;36mQExpandable.create_quantum_function_call\u001b[1;34m(self, *args, **kwargs)\u001b[0m\n\u001b[0;32m    111\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m \u001b[38;5;21mcreate_quantum_function_call\u001b[39m(\n\u001b[0;32m    112\u001b[0m     \u001b[38;5;28mself\u001b[39m, \u001b[38;5;241m*\u001b[39margs: Any, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs: Any\n\u001b[0;32m    113\u001b[0m ) \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m>\u001b[39m QuantumFunctionCall:\n\u001b[1;32m--> 114\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43m_create_quantum_function_call\u001b[49m\u001b[43m(\u001b[49m\u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mfunc_decl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;28;43;01mNone\u001b[39;49;00m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43margs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[38;5;241;43m*\u001b[39;49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_expandable.py:287\u001b[0m, in \u001b[0;36m_create_quantum_function_call\u001b[1;34m(decl_, index_, *args, **kwargs)\u001b[0m\n\u001b[0;32m    285\u001b[0m arg_decls \u001b[38;5;241m=\u001b[39m decl_\u001b[38;5;241m.\u001b[39mget_positional_arg_decls()\n\u001b[0;32m    286\u001b[0m arg_list \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mlist\u001b[39m(args)\n\u001b[1;32m--> 287\u001b[0m prepared_args \u001b[38;5;241m=\u001b[39m \u001b[43m_prepare_args\u001b[49m\u001b[43m(\u001b[49m\u001b[43mdecl_\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43marg_list\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mkwargs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[0;32m    289\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m kwargs:\n\u001b[0;32m    290\u001b[0m     bad_kwarg \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mnext\u001b[39m(\u001b[38;5;28miter\u001b[39m(kwargs))\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_expandable.py:274\u001b[0m, in \u001b[0;36m_prepare_args\u001b[1;34m(decl, arg_list, kwargs)\u001b[0m\n\u001b[0;32m    272\u001b[0m             error_message \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m _get_operand_hint(decl, arg_decl)\n\u001b[0;32m    273\u001b[0m         \u001b[38;5;28;01mraise\u001b[39;00m ClassiqValueError(error_message)\n\u001b[1;32m--> 274\u001b[0m     result\u001b[38;5;241m.\u001b[39mappend(\u001b[43mprepare_arg\u001b[49m\u001b[43m(\u001b[49m\u001b[43marg_decl\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43marg\u001b[49m\u001b[43m)\u001b[49m)\n\u001b[0;32m    276\u001b[0m \u001b[38;5;28;01mreturn\u001b[39;00m result\n",
      "File \u001b[1;32mc:\\Users\\casey\\AppData\\Local\\Programs\\Python\\Python311\\Lib\\site-packages\\classiq\\qmod\\quantum_expandable.py:210\u001b[0m, in \u001b[0;36mprepare_arg\u001b[1;34m(arg_decl, val)\u001b[0m\n\u001b[0;32m    208\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m Expression(expr\u001b[38;5;241m=\u001b[39m\u001b[38;5;28mstr\u001b[39m(val))\n\u001b[0;32m    209\u001b[0m \u001b[38;5;28;01melif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(arg_decl, PortDeclaration):\n\u001b[1;32m--> 210\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[43mval\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mget_handle_binding\u001b[49m()\n\u001b[0;32m    211\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[0;32m    212\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28misinstance\u001b[39m(val, \u001b[38;5;28mlist\u001b[39m):\n",
      "\u001b[1;31mAttributeError\u001b[0m: 'list' object has no attribute 'get_handle_binding'"
     ]
    }
   ],
   "source": [
    "@qfunc\n",
    "def main(psi: Output[QArray[QBit]]):\n",
    "    #Arguments for algorithm1()\n",
    "    sparse_states = {'000': 0.25, '001': 0.5, '111': 0.25}\n",
    "    NUM_QUBITS = len(next(iter(sparse_states)))\n",
    "    # might need an extra QBIT as per the guys instructions\n",
    "\n",
    "    # sets up the arrays fro algorithm 1 ot store values in\n",
    "    ops1 = [] # 1 for not, 2 for CNOT, 3 for G, 4 for end of circut\n",
    "    ops2 = [] # holds line/bit for not\n",
    "    ops3 = [] # holds control,target pair\n",
    "    ops4 = [] # holds params for G gate\n",
    "    ops5 = [] # what does this hold?????\n",
    "\n",
    "    n9 = []\n",
    "    # holds the numbers of iterations from the first while loop from algerithm 1 ????\n",
    "    \n",
    "    #End of arguments\n",
    "    #Allocate qubits for output\n",
    "    allocate(NUM_QUBITS, psi)\n",
    "\n",
    "    sparse_states = dict_to_3d_array(sparse_states)\n",
    "    if len(sparse_states[0]) > 1:\n",
    "        #Reference https://htor.inf.ethz.ch/publications/img/quantum_dac.pdf to understand algorithm_1() and its relationship to implementation\n",
    "        algorithm_1(sparse_states, NUM_QUBITS, ops1, ops2, ops3, ops4, ops5, n9)\n",
    "        #TODO YOUR CODE HERE\n",
    "        #Finish implementation to prepare sparse quantum state for psi   \n",
    "        \n",
    "        '''\n",
    "        at this point ops 1-5 have all the information \n",
    "        we need to create and run the circut\n",
    "        but we need to reverse and invert each gate\n",
    "        reversing is easy but inverting is not (might be easier than believed)\n",
    "        we need to add some extra not gates that (ARE THOSE WHAT IS IN OPS5)\n",
    "        '''\n",
    "        \n",
    "        # call order my_unitray -> some functions -> my_controlled_unitary\n",
    "        # those functions need to be dependent on the outputs from the algorithm_1 code\n",
    "        # apparently need and axilary qbit but for what?\n",
    "\n",
    "        # call of my_unitray\n",
    "        my_values = ops4[0] # instance of alpha and beta we are using to create the angle of rotation\n",
    "        omega = calc_angle(my_values[0], my_values[1])\n",
    "        # i think this call is formatted correctly but it is not working\n",
    "        # might need to have assignments within the function call?\n",
    "        my_unitary(q=sparse_states, w=omega, traget=int(1))\n",
    "        \n",
    "        # the previously specified 'some functions'\n",
    "        for i in range(len(ops1)-1, -1, -1):\n",
    "            # this for loop is reversed so now we just need to invert the calls also\n",
    "            match ops1[i]: # switch statement for better run time instead of if blocks\n",
    "                case 1:\n",
    "                    # not call\n",
    "                    # need to add a not gate to the circuit \n",
    "                    values = ops2[-1]\n",
    "                    ops2.remove(values) # might not have to do this\n",
    "                    sparse_states[0][values] = int(not sparse_states[0][values])\n",
    "                    break\n",
    "                case 2:\n",
    "                    # CNOT call\n",
    "                    values = ops3[-1]\n",
    "                    ops3.remove(values) # might not have to do this\n",
    "                    if sparse_states[0][values[0]] == 1:\n",
    "                        sparse_states[0][values[1]] = int(not sparse_states[0][values[1]])\n",
    "                    break\n",
    "                case 3:\n",
    "                    # G gate call\n",
    "                    # the g gate just roates so we need to simply rotate the other way\n",
    "                    values = ops4[-1]\n",
    "                    ops4.remove(values) # might not have to do this\n",
    "\n",
    "                    '''\n",
    "                    should be the reverse of the g gate but what \n",
    "                    even is the g gate in the first place?\n",
    "                    '''\n",
    "\n",
    "                    break\n",
    "                case 4:\n",
    "                    # end of circut\n",
    "                    # is this just a break statement since \n",
    "                    # we are at the end of the circut\n",
    "                    break\n",
    "            ops1.remove(i) # gets rid of the element we just added the inversted reversed gate for\n",
    "        \n",
    "        # call of my_controlled_unitary\n",
    "        # should be such a call that is acts like undoing the 'my_unitary' call\n",
    "        # problem is what does the angle need to be? and what should the control be?\n",
    "        my_controlled_unitary(q=sparse_states, w=-1*omega, ctrl=my_values[3], target=int(0))\n",
    "        \n",
    "        #TODO YOUR CODE ENDS HERE\n",
    "    else: # this handles when there is only one more qbit in the set of qbits\n",
    "         for b in range(NUM_QUBITS):\n",
    "            if sparse_states[0][0][b]==1:\n",
    "                X(psi[NUM_QUBITS-1-b])\n",
    "\n",
    "model = create_model(main)\n",
    "qprog = synthesize(model)\n",
    "show(qprog)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Good Luck!\n",
    "\n",
    "HINT: If you are getting inconsistent results when running code cells repeatedly, run all cells at once or restart your notebook kernel."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.0"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
