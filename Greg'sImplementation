#REGULAR FUNCS
def dict_to_3d_array(sparse_states):
    array_3d = []
    
    for key, value in sparse_states.items():
        point = [int(digit) for digit in key]
        array_3d.append([point, value])
    
    return array_3d

def custom_filter(func, iterable):
    return [item for item in iterable if func(item)]

def unequal_sets(t, n): 

    best_qubit = None
    T_0=[]
    T_1=[]
    current_difference = float('-inf')

    for b in range(n):    
        #Filter list based on boolean condition
        T_0 = custom_filter(lambda x, b=b: x[0][b] == 0, t)
        T_1 = custom_filter(lambda x, b=b: x[0][b] == 1, t)

        # Check if both sets are non-empty
        if len(T_0) != 0 and len(T_1) != 0:
            difference = abs(len(T_0) - len(T_1))
            #If new max difference
            if difference > current_difference:
                current_difference = difference
                best_qubit = b
                t_0 = T_0
                t_1 = T_1
    
    return best_qubit,t_0, t_1

def process_subsets(t, n, dif_qubits, dif_values):
    while len(t) > 1:
        b, T_0, T_1 = unequal_sets(t, n)
        dif_qubits.append(b)
        if len(T_0) < len(T_1):
            t = T_0
            dif_values.append(0)
        else:
            t = T_1
            dif_values.append(1)
    return dif_qubits, dif_values, t

def toggle_operations(index,n, x_x, ops1, ops2,s):
    if x_x[0][index] != 1: #Identical code
            ops1 += [1]
            ops2 += [n-1-index]
            for x in s:
                x[0][index]= int(not x[0][index])

def conditional_toggle(ops1,ops2,n,dif,b,s):
    ops1 += [2]
    sx = [n-1-dif,n-1-b]
    ops2 += [sx]
    for x in s:
        if x[0][dif] == 1:
            x[0][b] = int(not x[0][b])

def calc_alpha_beta(x_1,x_2):
    beta = x_1[1]
    alpha = x_2[1]

    x_2[1] = alpha+beta
    alpha = alpha/x_2[1]
    beta = beta/x_2[1]

    return alpha, beta

def calc_angle(alpha, beta):
    return np.arctan((beta)**.5/(alpha**.5))




#ALG 2 - GREG FRIEDMAN

@qfunc
def main(psi: Output[QArray[QBit]]):
    

    #Arguments for algorithm1()
    sparse_states = {'000': 0.25, '001': 0.5, '111': 0.25}
    NUM_QUBITS = len(next(iter(sparse_states)))

    ops1 = []#Stores operations
    ops2 = []
    ops3 = []
    ops4 = []
    ops5 = []
    n9 = []
    
    #End of arguments
    #Allocate qubits for output
    allocate(NUM_QUBITS, psi)

    sparse_states = dict_to_3d_array(sparse_states)
    if len(sparse_states[0]) > 1:
        #Reference https://htor.inf.ethz.ch/publications/img/quantum_dac.pdf to understand algorithm_1() and its relationship to implementation
        algorithm_1(sparse_states, NUM_QUBITS, ops1, ops2, ops3, ops4, ops5, n9)
        #TODO YOUR CODE HERE
        #Finish implementation to prepare sparse quantum state for psi
        
        ops = ops1
        nots = ops2 #val 1 in ops
        cnots = ops3 # val 2 for ops
        gParams = ops4 # parameters for G transform
        
        #operate on sparse_states
        
        #implement our own Not, CNot
        
        auxillary = QBit()
        
        for i in range(len(ops)-1,-1,-1): # problem?
            
            match ops[i]:
                
                case 1:
                    #not gate pop
                    pass
                case 2:
                    #cnot gate pop
                    pass
                case 3:
                    #G rotation pop
                    pass
                case 4:
                    break
        
        
                
        
            
        
        







        #TODO YOUR CODE ENDS HERE
    else:
         for b in range(NUM_QUBITS):
            if sparse_states[0][0][b]==1:
                X(psi[NUM_QUBITS-1-b])

model = create_model(main)
qprog = synthesize(model)
show(qprog)
